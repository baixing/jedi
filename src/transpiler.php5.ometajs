"import string, concat, flattenLines, isCharArray from './util'"
"export PHP5Transpiler"

ometa PHP5Transpiler {
	document = [#document [string:filename number number] string:source undefined topBlock:xs] -> (
		'<?php\n' +
		//flattenString(x) +
		flattenLines(xs).join('\n') +
		'\n?>'),

	topBlock = [ignore*:x doctype:y node*:xs] -> x.concat(y, xs),
	block = [node*:x] -> x,

	ignore	=	[char*:s]	->	string(s), // empty or ignore

	node ignore,
	node [#closeStartTag] -> "echo '>';",
	node [string:nodeType [number number] apply(nodeType):x] -> x,
	node :unknown -> ['/*', JSON.stringify(unknown), '*/'],

	Section :head :body -> ['/* Unknown section: ', JSON.stringify(string(head)), ' ... */'],

	doctype = [#comment [number number] [output:x]] -> x | -> ["echo '<!doctype html>', \"\\n\";"],
	output = [outputMethod:x] -> x,
	outputMethod spaces ("html" spaces? "5"?) spaces -> ["echo '<!doctype html>', \"\\n\";"],

	tupleItem [#Mapping [#Symbol :key] trans:expr] -> ("'" + key + "' => " + expr),
	trans [#Null] -> 'null',
	trans [#True] -> 'true',
	trans [#False] -> 'false',
	trans [#Number :n] -> String(n),
	trans [#String :s] -> ("'" + s.replace(/'/g, '\\\'') + "'"),
	trans [#String :s :raw] -> ("'" + s.replace(/'/g, '\\\'') + "'"),
	trans [#List [trans*:list]] -> ('[' + list.join(', ') + ']'),
	trans ["." [#Symbol 'url'] [#Symbol 'static']]
		-> 'UrlBuilder::staticResource',
	trans ["." trans:x [#Symbol :y]]
		-> (x + '->' + y),
	trans [#Call trans:x trans:y]
		-> (x + '(' + y + ')'),
	trans [#Tuple [trans*:list]] -> ('(' + list.join(', ') + ')'),

	trans [#Tuple [tupleItem*:list]] -> ('[' + list.join(', ') + ']'),

	trans ['...' trans:x trans:y]
		-> ('(range(' + x + ', ' + y + '))'),
	trans ['..<' trans:x trans:y]
		-> ('(range(' + x + ', ' + y + ' - 1))'),

	trans [#BinaryOp :op trans:x trans:y]
		-> ('(' + x + ' ' + op + ' ' + y + ')'),
	trans [#Symbol '*'] -> '$context',
	trans [#Symbol :s resolve(s):x] -> x,
	trans :unknown -> ['/*', JSON.stringify(unknown), '*/'],
	//trans [trans*:x] -> ( x ),

	comment [:line] -> ["echo '<!-- " + escapeComment(simpleString(line)) + " -->';"],
	comment [echoComment*:xs] -> [].concat(
			"echo '<!--', \"\\n\";",
			xs,
			"echo '-->';"
		),
	echoComment [char*:s] -> ("echo '" + escapeComment(simpleString(s)) + "', \"\\n\";"),

	text undefined [echoLine*:lines] -> lines,
	text undefined [echoTemplateString*:lines] -> lines,

	echoLine string:s -> ("echo '" + escapeText(simpleString(s)) + "', \"\\n\";"),
	echoTemplateString [trans*:exprList] -> ('echo htmlspecialchars(' + exprList.join('), htmlspecialchars(') + ');'),
	//	-> dom.text(lines),

	element [:tag :cls :id] undefined
		{startTag(tag, cls, id)}:startT
		enterBlock([]) block:body exitBlock
		{endTag(tag)}:endT
		-> this.elementOutput(tag, cls, id, undefined, body, startT, endT),

	element [:tag :cls :id] trans:bind
		{startTag(tag, cls, id)}:startT
		enterBlock([]) block:body exitBlock
		{endTag(tag)}:endT
		-> this.elementOutput(tag, cls, id, bind, body, startT, endT),


	attribute :name :op undefined -> ["echo ' " + name + "';"],
	attribute :name :op [#String :s] -> ["echo ' " + name + '="' + "" + attrValue(simpleString(s)) + "\"';"],
	attribute :name :op [#Quasi undefined [trans:exp]] -> ["echo ' " + name + '="' + "', htmlspecialchars(" + exp + "), '\"';"],
	attribute :name :op trans:exp -> ["echo ' " + name + '="' + "', htmlspecialchars(" + exp + "), '\"';"],
	
	binding :_ trans:expr [] -> ['echo htmlspecialchars(' + expr + ');'],
	//binding trans:expr [] -> ["$__temp = " + expr + "; if (method_exists($__temp, '__toString')) echo htmlspecialchars($__temp); else print_r($__temp);"],
	binding :_ trans:expr block:body
		-> closure(expr, body),

	instruction #if trans:expr block:b -> ["if (" + expr + ") {", b, "}"],
	instruction #else :_ block:b -> ["else {", b, "}"],

	instruction #for [bindingPattern:bind trans:expr]
		enterBlock(bind[0]) block:b exitBlock
		-> ["foreach (" + expr + " as " + bind[1] + ") {", b, "}"],
	bindingPattern [#Symbol :v] -> [[v], '$' + v],
	bindingPattern [#TuplePattern [[#Symbol :key] [#Symbol :value]]] -> [[key, value], '$' + key + ' => $' + value],

	suppress :lines -> (lines.map(function(line){ return '// ' + line })),
	fragment :name :_ block:b -> ['//  #' + name, b],
	macro :elementPattern paramPattern:parameter enterBlock(parameter) block:body exitBlock saveMacro(elementPattern, parameter, body)
		-> ['// define ' + elementPattern],

	paramPattern [#TuplePattern [([#Symbol :name] -> name)*:names]] -> names,

	endElement -> '',

	inject :x :y [string*:lines] -> [x + ';'].concat(lines.map(function(l){ return '//' + l })),
	inject :x :y block:body -> [x, '{', body, '}'],
	/*filter [#Symbol [``if'']] [spaces Expression.expression:exp node(exp):x] block:body
		-> ['if (' + x + ') {', body, '}'],
	filter [#Symbol [``else'']] :x block:body
		-> ['else {', body, '}'],

	Quasi :tag [trans*:templateStrings]
		-> [echo(closeStartTag()) + "Jedi::Quasi(" +
			(tag ? "'" + tag.join('') + "'": null) +
			", " +
			templateStrings.join(', ') +
			');'],

	//directive :type [apply(type):x] -> x,
	//node = directive (#Comment | #Suppress | #Inject | #Element | #Text | #Filter)
	//Element :tag [:cls, :id] :body ->*/

	END
}


PHP5Transpiler.initialize = function() {
	this._stack = [['page']]
	this.enterBlock = function(bindings) {
		this._stack.unshift(bindings)
	}
	this.exitBlock = function() {
		this._stack.shift()
	}
	this.resolve = function(symbol) {
		for (var i = 0; i < this._stack.length; i++) {
			if (this._stack[i].indexOf(symbol) >= 0) return '$' + symbol
		}
		return '$model->' + symbol
	}
	this.saveMacro = function(elementPattern, parameter, body) {
		if (this._stack[0].macros === undefined) this._stack[0].macros = []
		this._stack[0].macros.push([elementPattern, parameter, body])
	}
	this.elementOutput = function (tag, cls, id, bind, body, startT, endT) {
		if (bind === undefined) return [startT, body, endT]
		else {
			var m = this.findMacro(tag, cls, id, bind)
			body.some(function(node){
				return ['element', 'text', 'comment', 'instruction'].indexOf(node[0]) >= 0
			})
			return closure(bind, [startT, m, endT]) // || ['//call macro']
		}
	}
	this.findMacro = function (tag, cls, id, param) {
		for (var n = 0; n < this._stack.length; n++) {
			if (this._stack[n].macros)
				for (var i = 0; i < this._stack[n].macros.length; i++) {
					var m = this._stack[n].macros[i]
					var elemPattern = m[0]
					if (elemPattern[0] === tag &&
						elemPattern[1].every(function(c){ return cls.indexOf(c) >= 0 })) {
						return m[2]
					}
				}
		}
		return "echo '>', htmlspecialchars($context);"
		/*return [
			['closeStartTag'],
			['text', [0, 0], undefined, [['Symbol', '*']]]
		]*/
	}
}

function echo() {
	var args = [].slice.call(arguments).reduce(function(a, b){
		if (isCharArray(b)) b = b.join('')
		if (typeof b === 'string' && typeof a[a.length - 1] === 'string') {
			a[a.length - 1] += b
		} else {
			a.push(b)
		}
		return a
	}, []).map(function(o){
		if (typeof o === 'string') {
			return "'" + o.replace(/'/g, "\\'") + "'"
		}
		return JSON.stringify(o)
	})
	return 'echo ' + args.join(', ') + ';'
}
function echoLines(lines) {
	return lines.map(function(line) {
		return echo(line, '\n')
	})
}

function escapeComment(s) {
	// http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#comments
	// Comment must not contain two consecutive U+002D HYPHEN-MINUS characters (--)
	return s.replace(/--/g, '- -')
}
function escapeText(s) {
	return s.replace(/&/g, '&amp;').replace(/</g, '&lt;')
}
function simpleString(s) {
	return string(s).replace(/'/g, "\\'")
}
function attrValue(s) {
	return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;')
}

function startTag(tag, cls, id) {
	var r = echo(
		"<", tag,
		cls.length > 0 ? ' class="' + cls.join(' ') + '"': '',
		id ? ' id="' + id + '"' : '')
	return r
}
var voidElements = 'area,base,br,col,command,embed,hr,img,input,keygen,link,meta,param,source,track,wbr'.split(',')
function endTag(tag) {
	if (voidElements.indexOf(tag) >= 0) return []
	return echo('</', tag, '>')
}

function closure(context, body) {
	return [
		'call_user_func(function($context) {',
		body,
		'}, ' + context + ');'
	]
}

function htmlComment(lines) {
	return '<!--'
}


